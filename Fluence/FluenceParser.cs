using static Fluence.FluenceByteCode;
using static Fluence.FluenceByteCode.InstructionLine;
using static Fluence.Token;

namespace Fluence
{
    // No REPL for demo.
    // Needs exception handling.
    internal sealed class FluenceParser
    {
        private FluenceLexer _lexer;
        // Used to lex special, tiny bits of code, like expressions in f-string.
        private FluenceLexer _auxLexer;

        private ParseState _currentParseState;

        public List<InstructionLine> CompiledCode => _currentParseState.CodeInstructions;

        private class LoopContext
        {
            internal List<int> ContinuePatchAddresses { get; } = new List<int>();
            internal List<int> BreakPatchAddresses { get; } = new List<int>();

            internal LoopContext() { }
        }

        private class ParseState
        {
            internal List<InstructionLine> CodeInstructions = new List<InstructionLine>();
            internal Stack<LoopContext> ActiveLoopContexts = new Stack<LoopContext>();

            internal int NextTempNumber = 0;
            internal int CurrentTempNumber => NextTempNumber - 1;

            internal void AddCodeInstruction(InstructionLine instructionLine)
            {
                CodeInstructions.Add(instructionLine);
            }

            internal void AddInstructions(List<InstructionLine> codes)
            {
                CodeInstructions.AddRange(codes);
            }
        }

        internal FluenceParser(FluenceLexer lexer)
        {
            _currentParseState = new();
            _lexer = lexer;
        }

        internal void Parse()
        {
            _currentParseState.AddCodeInstruction(new InstructionLine(
                    InstructionCode.CallFunction,
                    new TempValue(_currentParseState.NextTempNumber++),
                    new VariableValue("Main"),
                    new NumberValue(0)
                )
            );

            ParseTokens();
            // We add a universal TERMINATE instruction for the VM, at the very end of the generated byte code.
            // Both for convenience and so that we dont end on dangling instructions, like add and any other.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Terminate, null));
        }

        private void ParseTokens()
        {
            while (!_lexer.HasReachedEnd)
            {
                _lexer.TrySkipEOLToken();
                if (_lexer.HasReachedEnd) break;

                // We reached end of file, so we just quit.
                if (_lexer.PeekNextToken().Type == TokenType.EOF)
                {
                    _lexer.ConsumeToken();
                    break;
                }

                ParseStatement();
            }
        }

        private void ParseStatement()
        {
            if (_lexer.PeekNextToken().Type == TokenType.EOL)
            {
                // It's a blank line. This is a valid, empty statement.
                // Consume the EOL token and simply return. We are done with this statement.
                _lexer.ConsumeToken();
                return;
            }

            Token token = _lexer.PeekNextToken();

            bool isNotAPrimaryKeyword =
                token.Type != TokenType.IS &&
                token.Type != TokenType.NOT &&
                token.Type != TokenType.TRUE &&
                token.Type != TokenType.FALSE &&
                token.Type != TokenType.NIL;

            // Primary keywords like func, if, else, return, loops, and few others.
            if (FluenceKeywords.TokenTypeIsAKeywordType(token.Type) && isNotAPrimaryKeyword)
            {
                switch (token.Type)
                {
                    case TokenType.IF:
                        ParseIfStatement();
                        break;
                    case TokenType.LOOP:
                        ParseLoopStatement();
                        break;
                    case TokenType.BREAK:
                        _lexer.ConsumeToken(); // Consume break;

                        if (_currentParseState.ActiveLoopContexts.Count == 0) { /* throw error: 'break' outside loop */ }
                        LoopContext currentLoop = _currentParseState.ActiveLoopContexts.Peek();

                        _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, null));
                        currentLoop.BreakPatchAddresses.Add(_currentParseState.CodeInstructions.Count - 1);
                        break;
                    case TokenType.CONTINUE:
                        _lexer.ConsumeToken(); // Consume 'continue'
                        if (_currentParseState.ActiveLoopContexts.Count == 0) { /* throw error */ }

                        LoopContext currentLoop2 = _currentParseState.ActiveLoopContexts.Peek();

                        _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, null));

                        currentLoop2.ContinuePatchAddresses.Add(_currentParseState.CodeInstructions.Count - 1);
                        break;
                    case TokenType.WHILE:
                        ParseWhileStatement();
                        break;
                    case TokenType.FOR:
                        ParseForStatement();
                        break;
                    case TokenType.FUNC:
                        ParseFunction();
                        break;
                    case TokenType.RETURN:
                        ParseReturnStatement();
                        break;
                }
            }
            // Most likely an expression
            else
            {
                ParseAssignment();

                Token next = _lexer.PeekNextToken();

                if (next.Type == TokenType.EOL)
                {
                    if (next.Text != ";" && next.Text != ";\r\n" && next.Text != ";\n") throw new Exception("; mandate");
                }

                if (next.Type == TokenType.EOF)
                {
                    return;
                }

                // If we reach here, then we lack a semicolon, most likely at the end of an expression,
                // not within if/loops/etc. Or we have a bug.
                ConsumeAndTryThrowIfUnequal(TokenType.EOL, $"Syntax Error: Missing newline or ';' to terminate the statement. Line {_lexer.CurrentLine}");
            }
        }

        private void ParseForStatement()
        {
            _lexer.ConsumeToken(); // Consume for.

            // For x in ... statement.
            if (_lexer.PeekAheadByN(2).Type == TokenType.IN)
            {
                ParseForInStatement();
            }
            else
            {
                ParseForCStyleStatement();
            }
        }

        private void ParseForCStyleStatement()
        {
            // Part 1: Initializer (e.g., "i = 0;")
            // This runs once before the loop begins.
            ParseStatement();

            // Part 2: Condition (e.g., "i < 10")
            Value condition = ParseExpression();
            int conditionCheckIndex = _currentParseState.CodeInstructions.Count;
            _lexer.ConsumeToken(); // Consume the ;

            // Add a placeholder jump that will exit the loop if the condition is false.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GotoIfFalse, null, condition));
            int loopExitPatchIndex = _currentParseState.CodeInstructions.Count - 1;

            // Add a placeholder jump to skip over the incrementer and go directly to the loop body.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, null));
            int loopBodyJumpPatchIndex = _currentParseState.CodeInstructions.Count - 1;

            // Part 3: Incrementer (e.g., "i += 1")
            // This is where 'continue' statements will jump to.
            int incrementerStartIndex = _currentParseState.CodeInstructions.Count;
            ParseAssignment();
            _lexer.ConsumeToken(); // Consume the ;

            // After the incrementer runs, add a jump back to the condition check.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, new NumberValue(conditionCheckIndex - 1, NumberValue.NumberType.Integer)));

            var loopContext = new LoopContext();
            _currentParseState.ActiveLoopContexts.Push(loopContext);

            int bodyStartIndex = _currentParseState.CodeInstructions.Count;
            if (_lexer.PeekNextToken().Type == TokenType.L_BRACE)
            {
                ParseBlockStatement();
            }
            else
            {
                ConsumeAndTryThrowIfUnequal(TokenType.THIN_ARROW, "Expected '->' token for single line for loop statement");
                ParseStatement();
            }

            // At the end of the body, add a jump to the incrementer.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, new NumberValue(incrementerStartIndex, NumberValue.NumberType.Integer)));

            // Patch the jump that skips the incrementer to now point to the body.
            _currentParseState.CodeInstructions[loopBodyJumpPatchIndex].Lhs = new NumberValue(bodyStartIndex, NumberValue.NumberType.Integer);

            // The loop officially ends at the current instruction count.
            int loopEndAddress = _currentParseState.CodeInstructions.Count;

            // Patch the main exit jump to point to the instruction after the loop.
            _currentParseState.CodeInstructions[loopExitPatchIndex].Lhs = new NumberValue(loopEndAddress, NumberValue.NumberType.Integer);

            // Patch all 'break' statements to also jump to the end of the loop.
            foreach (var patchIndex in loopContext.BreakPatchAddresses)
            {
                _currentParseState.CodeInstructions[patchIndex].Lhs = new NumberValue(loopEndAddress, NumberValue.NumberType.Integer);
            }

            foreach (var patchIndex in loopContext.ContinuePatchAddresses)
            {
                _currentParseState.CodeInstructions[patchIndex].Lhs = new NumberValue(incrementerStartIndex, NumberValue.NumberType.Integer);
            }

            _currentParseState.ActiveLoopContexts.Pop();
        }

        private void ParseForInStatement()
        {
            Token itemToken = ConsumeAndTryThrowIfUnequal(TokenType.IDENTIFIER, "Expected loop variable name after 'for'.");
            VariableValue loopVariable = new VariableValue(itemToken.Text);

            ConsumeAndTryThrowIfUnequal(TokenType.IN, "Expected 'in' keyword in for-loop.");

            Value collectionExpr = ParseExpression();

            // Create hidden variables for the index and the collection copy.
            TempValue indexVar = new TempValue(_currentParseState.NextTempNumber++, "ForInIndex");
            TempValue collectionVar = new TempValue(_currentParseState.NextTempNumber++, "ForInCollectionCopy");

            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, indexVar, new NumberValue(0, NumberValue.NumberType.Integer)));
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, collectionVar, collectionExpr));

            int loopTopAddress = _currentParseState.CodeInstructions.Count;

            var loopContext = new LoopContext();
            _currentParseState.ActiveLoopContexts.Push(loopContext);

            TempValue lengthVar = new TempValue(_currentParseState.NextTempNumber++, "ForInCollectionLen");
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GetLength, lengthVar, collectionVar));
            TempValue conditionVar = new TempValue(_currentParseState.NextTempNumber++);
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.LessThan, conditionVar, indexVar, lengthVar));

            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GotoIfFalse, null, conditionVar));
            int loopExitPatchIndex = _currentParseState.CodeInstructions.Count - 1;

            // Assign the loop variable: `item = collection[index]`
            TempValue currentElementVar = new TempValue(_currentParseState.NextTempNumber++);
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GetElement, currentElementVar, collectionVar, indexVar));
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, loopVariable, currentElementVar));

            // ForIn has two forms, block {...} or ForIn cond -> ...;
            if (_lexer.PeekNextToken().Type == TokenType.L_BRACE)
            {
                ParseBlockStatement();
            }
            else
            {
                ConsumeAndTryThrowIfUnequal(TokenType.THIN_ARROW, "Expected '->' token for single line if/else/else-if statement");
                ParseStatement();
            }

            // Increment the index: `index = index + 1`
            TempValue incrementedIndex = new TempValue(_currentParseState.NextTempNumber++);
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Add, incrementedIndex, indexVar, new NumberValue(1)));
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, indexVar, incrementedIndex));

            // Unconditional jump back to the top to re-check the condition.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, new NumberValue(loopTopAddress)));

            int loopEndAddress = _currentParseState.CodeInstructions.Count;
            _currentParseState.CodeInstructions[loopExitPatchIndex].Lhs = new NumberValue(loopEndAddress);

            foreach (var patchIndex in loopContext.BreakPatchAddresses)
            {
                _currentParseState.CodeInstructions[patchIndex].Lhs = new NumberValue(loopEndAddress);
            }

            int continueAddress = loopEndAddress - 3;
            foreach (var patchIndex in loopContext.ContinuePatchAddresses)
            {
                _currentParseState.CodeInstructions[patchIndex].Lhs = new NumberValue(continueAddress);
            }

            _currentParseState.ActiveLoopContexts.Pop();
        }

        private void ParseWhileStatement()
        {
            _lexer.ConsumeToken(); // Consume while.

            Value condition = ParseExpression();

            int loopStartIndex = _currentParseState.CodeInstructions.Count;
            LoopContext whileContext = new LoopContext();
            _currentParseState.ActiveLoopContexts.Push(whileContext);

            // the condition of the while, we must jump back here if loop reaches end ( not terminated by break ).
            // We'll patch this later.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GotoIfFalse, null, condition));
            int loopExitPatch = _currentParseState.CodeInstructions.Count - 1;

            // While has two forms, block {...} or while cond -> ...;
            if (_lexer.PeekNextToken().Type == TokenType.L_BRACE)
            {
                ParseBlockStatement();
            }
            else
            {
                ConsumeAndTryThrowIfUnequal(TokenType.THIN_ARROW, "Expected '->' token for single line if/else/else-if statement");
                ParseStatement();
            }

            // We jump to the start of the loop, which is the condition check.
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, new NumberValue(loopStartIndex - 1, NumberValue.NumberType.Integer)));

            int loopEndIndex = _currentParseState.CodeInstructions.Count;

            // Patch our GoToIfFalse.
            _currentParseState.CodeInstructions[loopExitPatch].Lhs = new NumberValue(loopEndIndex, NumberValue.NumberType.Integer);

            // Assign breakPatches to the end of the loop, or the instruction after if there is more code.
            foreach (int breakPatch in whileContext.BreakPatchAddresses)
            {
                _currentParseState.CodeInstructions[breakPatch].Lhs = new NumberValue(loopEndIndex, NumberValue.NumberType.Integer);
            }

            int continueAddress = loopStartIndex;
            // Patch all 'continue' statements to jump to the top.
            foreach (var patchIndex in whileContext.ContinuePatchAddresses)
            {
                _currentParseState.CodeInstructions[patchIndex].Lhs = new NumberValue(continueAddress);
            }
            _currentParseState.ActiveLoopContexts.Pop();
        }

        private void ParseLoopStatement()
        {
            _lexer.ConsumeToken(); // Consume loop

            int loopStartIndex = _currentParseState.CodeInstructions.Count;
            LoopContext loopContext = new LoopContext();
            _currentParseState.ActiveLoopContexts.Push(loopContext);

            ParseBlockStatement();

            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, new NumberValue(loopStartIndex, NumberValue.NumberType.Integer)));

            int loopEndIndex = _currentParseState.CodeInstructions.Count;
            foreach (int breakPatch in loopContext.BreakPatchAddresses)
            {
                _currentParseState.CodeInstructions[breakPatch].Lhs = new NumberValue(loopEndIndex, NumberValue.NumberType.Integer);
            }

            foreach (var patchIndex in loopContext.ContinuePatchAddresses)
            {
                _currentParseState.CodeInstructions[patchIndex].Lhs = new NumberValue(loopStartIndex, NumberValue.NumberType.Integer);
            }
            _currentParseState.ActiveLoopContexts.Pop();
        }

        private void ParseIfStatement()
        {
            _lexer.ConsumeToken(); // Consume the if.
            var condition = ParseExpression();

            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GotoIfFalse, null, condition));

            int elsePatchIndex = _currentParseState.CodeInstructions.Count - 1;

            // ifs come into ways, a block body if ... { ... }
            // or one line expressions, if ... -> .... ;
            if (_lexer.PeekNextToken().Type == TokenType.L_BRACE)
            {
                ParseBlockStatement();
            }
            else  // Single line if, expects ; instead.
            {
                ConsumeAndTryThrowIfUnequal(TokenType.THIN_ARROW, "Expected '->' token for single line if/else/else-if statement");
                ParseStatement();
            }

            // Skips EOLS in between.
            while (_lexer.PeekNextToken().Type == TokenType.EOL && !_lexer.HasReachedEnd) _lexer.ConsumeToken();

            // else, also handles else if, we just consume the else part, call parse with the rest.
            if (_lexer.PeekNextToken().Type == TokenType.ELSE)
            {
                int elseIfJumpOverIndex = _currentParseState.CodeInstructions.Count;
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, null));

                _lexer.ConsumeToken();

                int elseAddress = _currentParseState.CodeInstructions.Count;
                _currentParseState.CodeInstructions[elsePatchIndex].Lhs = new NumberValue(elseAddress, NumberValue.NumberType.Integer);

                // This is an else-if, we just call ParseIf again.
                if (_lexer.PeekNextToken().Type == TokenType.IF)
                {
                    ParseStatement();
                }
                else if (_lexer.PeekNextToken().Type == TokenType.L_BRACE)
                {
                    ParseBlockStatement();
                }
                else // single line else.
                {
                    ConsumeAndTryThrowIfUnequal(TokenType.THIN_ARROW, "Expected '->' token for single line if/else/else-if statement");
                    ParseStatement();
                }

                _currentParseState.CodeInstructions[elseIfJumpOverIndex].Lhs = new NumberValue(_currentParseState.CodeInstructions.Count, NumberValue.NumberType.Integer);
            }
            else
            {
                // No other else/else-ifs.
                int endAddress = _currentParseState.CodeInstructions.Count;
                _currentParseState.CodeInstructions[elsePatchIndex].Lhs = new NumberValue(endAddress, NumberValue.NumberType.Integer);
            }
        }

        private void ParseReturnStatement()
        {
            _lexer.ConsumeToken(); // Consume return;

            Value result = null;

            // return;
            if (_lexer.PeekNextToken().Type == TokenType.EOL)
            {
                result = new NilValue();
            }
            else
            {
                result = ParseExpression();
            }

            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Return, result));
        }

        private static string FormatByteCodeAddress(int startAddress)
        {
            if (startAddress < 10) return $"000{startAddress}";
            if (startAddress < 100) return $"00{startAddress}";
            if (startAddress < 1000) return $"0{startAddress}";
            if (startAddress < 1000) return $"{startAddress}";
            return "-1";
        }

        private void ParseFunction()
        {
            _lexer.ConsumeToken(); // Consume func.

            Token nameToken = ConsumeAndTryThrowIfUnequal(TokenType.IDENTIFIER, "Expected function name.");
            string functionName = nameToken.Text;

            ConsumeAndTryThrowIfUnequal(TokenType.L_PAREN, "Expected '(' after function name.");

            List<string> parameters = new List<string>();
            // Has arguments
            if (_lexer.PeekNextToken().Type != TokenType.R_PAREN)
            {
                while (_lexer.PeekNextToken().Type == TokenType.IDENTIFIER)
                {
                    parameters.Add(_lexer.ConsumeToken().Text);
                    if (_lexer.PeekNextToken().Type == TokenType.COMMA)
                    {
                        _lexer.ConsumeToken();
                    }
                }
            }

            ConsumeAndTryThrowIfUnequal(TokenType.R_PAREN, "No closing parenthesis '}' after function args.");
            ConsumeAndTryThrowIfUnequal(TokenType.ARROW, "No arrow after function declaration");

            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, null));
            int jumpOverBodyGoTo = _currentParseState.CodeInstructions.Count - 1;

            int functionStartAddress = _currentParseState.CodeInstructions.Count + 1;

            FunctionValue func = new FunctionValue(functionName, parameters.Count, functionStartAddress, FormatByteCodeAddress(functionStartAddress));
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, new VariableValue(functionName), func));

            // Either => for one line, or => {...} for a block.
            if (_lexer.PeekNextToken().Type == TokenType.L_BRACE)
            {
                ParseBlockStatement();
                if (_currentParseState.CodeInstructions[^1].Instruction != InstructionCode.Return) ;
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Return, new NilValue()));
            }
            else
            {
                // func Test() =>, this format is just for returning something.
                Value returnValue = ParseExpression();
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Return, returnValue));
            }

            int afterBodyAddress = _currentParseState.CodeInstructions.Count;
            _currentParseState.CodeInstructions[jumpOverBodyGoTo].Lhs = new NumberValue(afterBodyAddress);
        }

        private Value ParseMatch()
        {
            // Match is already consumed.

            Value matchOn = ParseExpression();

            Console.WriteLine(matchOn);

            return null;
        }

        private Value ConcatenateStringValues(Value left, Value right)
        {
            if (left == null) return right;
            if (right == null) return left;

            TempValue temp = new TempValue(_currentParseState.NextTempNumber++);
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Add, temp, left, right));
            return temp;
        }

        private Value ParseFString(object literal)
        {
            // f".... {var} ....".
            string str = literal.ToString();

            Value result = null;
            int lastIndex = 0;

            while (lastIndex < str.Length)
            {
                int exprStart = str.IndexOf('{', lastIndex);

                if (exprStart == -1)
                {
                    string end = str[lastIndex..];
                    result = ConcatenateStringValues(result, new StringValue(end));
                    break;
                }

                string startOfLiteral = str[lastIndex..exprStart];
                if (!string.IsNullOrEmpty(startOfLiteral))
                {
                    result = ConcatenateStringValues(result, new StringValue(startOfLiteral));
                }

                int exprClose = str.IndexOf('}', exprStart);

                // no closing }
                if (exprClose == -1)
                {
                    // error?
                }

                // skip { at start, } at end.
                string expr = str.Substring(exprStart + 1, exprClose - exprStart - 1);

                // We push our main code's token stream into the aux lexer,
                // In the current lexer we put the {expr}, parse it, then we switch back.
                _auxLexer = _lexer;
                _lexer = new FluenceLexer(expr);

                Value exprInside = ParseExpression();
                _lexer = _auxLexer;

                TempValue temp = new TempValue(_currentParseState.NextTempNumber++);
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.ToString, temp, exprInside));

                result = ConcatenateStringValues(result, temp);

                lastIndex = exprClose + 1;
            }

            return result ?? new StringValue("");
        }

        private Value ParseList()
        {
            // [ is already consumed.

            TempValue temp = new TempValue(_currentParseState.NextTempNumber++);
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.NewList, temp));

            // Empty list: [].
            if (_lexer.PeekNextToken().Type == TokenType.R_BRACKET)
            {
                _lexer.ConsumeToken(); // Consume ending bracket ].
                return temp;
            }

            // Non empty array, parse and push first element, the while loop will likely encounter a comma,
            // if not the list has just one element.
            Value firstElement = ParseExpression();
            _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.PushElement, temp, firstElement));

            while (_lexer.PeekNextToken().Type == TokenType.COMMA)
            {

                _lexer.ConsumeToken(); // Consume comma.

                if (_lexer.PeekNextToken().Type == TokenType.R_BRACKET) // Trailing comma in list.
                {
                    Console.WriteLine("Trailing comma in list");
                    throw new Exception();
                }

                Value rhs = ParseExpression();
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.PushElement, temp, rhs));
            }

            _lexer.ConsumeToken(); // Consume ].

            return temp;
        }

        private void ParseBlockStatement()
        {
            ConsumeAndTryThrowIfUnequal(TokenType.L_BRACE, "Expected '{' to start a block.");
            while (_lexer.PeekNextToken().Type != TokenType.R_BRACE)
            {
                ParseStatement();
            }
            ConsumeAndTryThrowIfUnequal(TokenType.R_BRACE, "Expected '}' to end a block.");
        }

        private static bool IsAssignmentOperator(TokenType type) => type switch
        {
            TokenType.EQUAL or
            TokenType.EQUAL_DIV or
            TokenType.EQUAL_MINUS or
            TokenType.EQUAL_PLUS or
            TokenType.EQUAL_MUL or
            TokenType.EQUAL_AMPERSAND or
            TokenType.EQUAL_PERCENT => true,
            _ => false,
        };

        private static bool IsUnaryOperator(TokenType type) => type switch
        {
            TokenType.DECREMENT or
            TokenType.INCREMENT or
            TokenType.MINUS => true,
            _ => false,
        };

        private void ParseAssignment()
        {
            // (=, +=, -=, *=, /=) - LOWEST PRECEDENCE
            Value lhs = ParseTernary();

            TokenType type = _lexer.PeekNextToken().Type;

            if (IsAssignmentOperator(type) || type == TokenType.SWAP)
            {
                _lexer.ConsumeToken(); // Consume the "="

                // Parse the right-hand side expression.
                Value rhs = ParseTernary();

                if (type == TokenType.EQUAL)
                {
                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, lhs, rhs));
                }
                else if (type == TokenType.SWAP)
                {
                    Value temp = new TempValue(_currentParseState.NextTempNumber++);

                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, temp, lhs));
                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, lhs, rhs));
                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, rhs, temp));
                }
                else  // Compound, -=, +=, etc.
                {
                    InstructionCode instrType = GetInstructionCode(type);

                    TempValue temp = new TempValue(_currentParseState.NextTempNumber++);

                    // temp = var - value.
                    _currentParseState.AddCodeInstruction(new InstructionLine(instrType, temp, lhs, rhs));

                    // var = temp.
                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, lhs, temp));
                }
            }
            else
            {
                if (lhs is StatementCompleteValue)
                {
                    // do nothing
                }
                else if (lhs is VariableValue variable)
                {
                    // The expression was just a variable. Force a read.
                    var temp = new TempValue(_currentParseState.NextTempNumber++);
                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, temp, variable));
                }
            }
        }

        private Value ParseTernary()
        {
            // If Ternary, this becomes the condition.
            Value left = ParseExpression();

            TokenType type = _lexer.PeekNextToken().Type;

            // Two formats, normal: cond ? a : b
            // Joint: cond ?: a, b
            if (type == TokenType.TERNARY_JOINT || type == TokenType.QUESTION)
            {
                _lexer.ConsumeToken(); // Consume '?' or '?:'

                // Immediately generate the conditional jump. We will back-patch its target.
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GotoIfFalse, null, left));
                int falseJumpPatch = _currentParseState.CodeInstructions.Count - 1;

                Value trueExpr = ParseTernary();

                TempValue result = new TempValue(_currentParseState.NextTempNumber++);
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, result, trueExpr));

                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Goto, null));
                int endJumpPatch = _currentParseState.CodeInstructions.Count - 1;

                int falsePathAddress = _currentParseState.CodeInstructions.Count;
                _currentParseState.CodeInstructions[falseJumpPatch].Lhs = new NumberValue(falsePathAddress);

                // 7. Consume the ':' or ',' delimiter.
                if (type == TokenType.QUESTION)
                {
                    ConsumeAndTryThrowIfUnequal(TokenType.COLON, "Expected ':' in standard ternary.");
                }
                else
                {
                    ConsumeAndTryThrowIfUnequal(TokenType.COMMA, "Expected ',' in Fluid-style ternary.");
                }

                // Recursively parse the "false" path expression.
                Value falseExpr = ParseTernary();
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, result, falseExpr));

                int endAddress = _currentParseState.CodeInstructions.Count;
                _currentParseState.CodeInstructions[endJumpPatch].Lhs = new NumberValue(endAddress);

                // The "value" of this entire ternary expression for the rest of the parser
                // is the temporary variable that holds the chosen result.
                return result;
            }

            return left;
        }

        private static InstructionCode GetInstructionCode(TokenType type) => type switch
        {
            // LEVEL 1: ASSIGNMENT (=, +=, -=, *=, /=) - LOWEST PRECEDENCE
            TokenType.EQUAL_PLUS => InstructionCode.Add,
            TokenType.EQUAL_MINUS => InstructionCode.Subtract,
            TokenType.EQUAL_MUL => InstructionCode.Multiply,
            TokenType.EQUAL_DIV => InstructionCode.Divide,
            TokenType.EQUAL_PERCENT => InstructionCode.Modulo,
            TokenType.EQUAL_AMPERSAND => InstructionCode.BitwiseAnd,

            //  LEVEL 2: ADDITION AND SUBTRACTION (+, -)
            TokenType.PLUS => InstructionCode.Add,
            TokenType.MINUS => InstructionCode.Subtract,

            // Precedent level 3: MULTIPLICATION, DIVISION, MODULO (*, /, %)
            TokenType.STAR => InstructionCode.Multiply,
            TokenType.SLASH => InstructionCode.Divide,
            TokenType.PERCENT => InstructionCode.Modulo,

            // Precedent level 4: EXPONENTIATION (**)
            TokenType.EXPONENT => InstructionCode.Power,

            // LEVEL 5: UNARY OPERATORS (-, ++, --)
            // TokenType.MINUS => InstructionCode.Subtract,
            TokenType.INCREMENT => InstructionCode.Increment,
            TokenType.DECREMENT => InstructionCode.Decrement,

            // Equality
            TokenType.EQUAL_EQUAL => InstructionCode.Equal,
            TokenType.BANG_EQUAL => InstructionCode.NotEqual,

            // Comparisons
            TokenType.GREATER => InstructionCode.GreaterThan,
            TokenType.LESS => InstructionCode.LessThan,
            TokenType.GREATER_EQUAL => InstructionCode.GreaterEqual,
            TokenType.LESS_EQUAL => InstructionCode.LessEqual,

            TokenType.BITWISE_LEFT_SHIFT => InstructionCode.BitwiseLShift,
            TokenType.BITWISE_RIGHT_SHIFT => InstructionCode.BitwiseRShift,
            TokenType.TILDE => InstructionCode.BitwiseNot,
            TokenType.CARET => InstructionCode.BitwiseXor,
            TokenType.PIPE_CHAR => InstructionCode.BitwiseOr,
            TokenType.AMPERSAND => InstructionCode.BitwiseAnd,

            _ => InstructionCode.Skip
        };

        private Value ParseExpression()
        {
            // for now
            return ParseLogicalOr();
        }

        private Value ParseLogicalOr()
        {
            // This calls the next higher precedence level.
            Value left = ParseLogicalAnd();

            while (_lexer.PeekNextToken().Type == TokenType.OR)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseLogicalAnd();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Or, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private Value ParseLogicalAnd()
        {
            // This calls the next higher precedence level.
            Value left = ParseBitwiseOr();

            while (_lexer.PeekNextToken().Type == TokenType.AND)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseBitwiseOr();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.And, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private Value ParseBitwiseOr()
        {
            // This calls the next higher precedence level.
            Value left = ParseBitwiseXor();

            // | is called PIPE_CHAR.
            while (_lexer.PeekNextToken().Type == TokenType.PIPE_CHAR)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseBitwiseXor();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.BitwiseOr, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private Value ParseBitwiseXor()
        {
            // This calls the next higher precedence level.
            Value left = ParseBitwiseAnd();

            // ^
            while (_lexer.PeekNextToken().Type == TokenType.CARET)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseBitwiseAnd();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.BitwiseXor, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private Value ParseBitwiseAnd()
        {
            // This calls the next higher precedence level.
            Value left = ParseEquality();

            // &
            while (_lexer.PeekNextToken().Type == TokenType.AMPERSAND)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseEquality();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.BitwiseAnd, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private Value ParseEquality()
        {
            // This calls the next higher precedence level.
            Value left = ParseBitwiseShift();

            while (_lexer.PeekNextToken().Type == TokenType.EQUAL_EQUAL || _lexer.PeekNextToken().Type == TokenType.BANG_EQUAL)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseBitwiseShift();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);
                var opcode = (op.Type == TokenType.EQUAL_EQUAL)
                    ? InstructionCode.Equal
                    : InstructionCode.NotEqual;

                _currentParseState.AddCodeInstruction(new InstructionLine(opcode, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private Value ParseBitwiseShift()
        {
            // This calls the next higher precedence level.
            Value left = ParseComparison();

            while (_lexer.PeekNextToken().Type == TokenType.BITWISE_LEFT_SHIFT || _lexer.PeekNextToken().Type == TokenType.BITWISE_RIGHT_SHIFT)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseComparison();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);
                var opcode = (op.Type == TokenType.BITWISE_LEFT_SHIFT)
                    ? InstructionCode.BitwiseLShift
                    : InstructionCode.BitwiseRShift;

                _currentParseState.AddCodeInstruction(new InstructionLine(opcode, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private static bool IsComparisonTokenType(TokenType type) =>
            type == TokenType.GREATER ||
            type == TokenType.LESS ||
            type == TokenType.GREATER_EQUAL ||
            type == TokenType.LESS_EQUAL;

        private Value ParseComparison()
        {
            Value left = ParseRange();

            // Potential collective comparison
            if (_lexer.PeekNextToken().Type == TokenType.COMMA)
            {
                // indeed so.
                if (IsCollectiveComparisonAhead())
                {
                    List<Value> args = new List<Value>() { left };
                    _lexer.ConsumeToken();

                    do
                    {
                        args.Add(ParseRange());
                    } while (ConsumeTokenIfMatch(TokenType.COMMA) && IsNotAStandardComparison(_lexer.PeekNextToken().Type));

                    return GenerateCollectiveComparisonByteCode(args, _lexer.ConsumeToken(), ParseRange());
                }
            }

            while (IsComparisonTokenType(_lexer.PeekNextToken().Type))
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseRange();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(GetInstructionCode(op.Type), temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private static bool IsNotAStandardComparison(TokenType type)
        {
            return !IsComparisonTokenType(type) && type != TokenType.EQUAL_EQUAL && type != TokenType.BANG_EQUAL;
        }

        private bool IsCollectiveComparisonAhead()
        {
            int lookahead = 1;
            bool hasComma = false;

            while (true)
            {
                TokenType type = _lexer.PeekAheadByN(lookahead).Type;

                if (type == TokenType.COMMA) hasComma = true;

                if (IsCollectiveOperator(type) && hasComma)
                {
                    return true; // Found the pattern.
                }

                // Stop conditions
                if (type == TokenType.L_BRACE || type == TokenType.THIN_ARROW || type == TokenType.EOF)
                {
                    return false; // Reached the end of the potential condition.
                }

                lookahead++;
            }
        }

        private Value GenerateCollectiveComparisonByteCode(List<Value> lhsExprs, Token op, Value rhs)
        {
            Value result = null;

            InstructionCode comparisonType = GetComparisonInstructionCodeFromCollectiveOp(op.Type);
            InstructionCode logicalOp = IsOrCollectiveOperator(op.Type) ? InstructionCode.Or : InstructionCode.And;

            foreach (Value lhs in lhsExprs)
            {
                TempValue currentResult = new TempValue(_currentParseState.NextTempNumber++);
                _currentParseState.AddCodeInstruction(new InstructionLine(comparisonType, currentResult, lhs, rhs));

                if (result == null)
                {
                    result = currentResult;
                }
                else
                {
                    TempValue combinedResult = new TempValue(_currentParseState.NextTempNumber++);
                    _currentParseState.AddCodeInstruction(new InstructionLine(logicalOp, combinedResult, result, currentResult));
                    result = combinedResult;
                }
            }

            return result;
        }

        private static bool IsOrCollectiveOperator(TokenType type) => type switch
        {
            TokenType.COLLECTIVE_OR_EQUAL => true,
            TokenType.COLLECTIVE_OR_NOT_EQUAL => true,
            TokenType.COLLECTIVE_OR_LESS => true,
            TokenType.COLLECTIVE_OR_LESS_EQUAL => true,
            TokenType.COLLECTIVE_OR_GREATER => true,
            TokenType.COLLECTIVE_OR_GREATER_EQUAL => true,
            _ => false
        };

        private static InstructionCode GetComparisonInstructionCodeFromCollectiveOp(TokenType type) => type switch
        {
            TokenType.COLLECTIVE_EQUAL => InstructionCode.Equal,
            TokenType.COLLECTIVE_NOT_EQUAL => InstructionCode.NotEqual,
            TokenType.COLLECTIVE_GREATER => InstructionCode.GreaterThan,
            TokenType.COLLECTIVE_GREATER_EQUAL => InstructionCode.GreaterEqual,
            TokenType.COLLECTIVE_LESS => InstructionCode.LessThan,
            TokenType.COLLECTIVE_LESS_EQUAL => InstructionCode.LessEqual,
            TokenType.COLLECTIVE_OR_EQUAL => InstructionCode.Equal,
            TokenType.COLLECTIVE_OR_NOT_EQUAL => InstructionCode.NotEqual,
            TokenType.COLLECTIVE_OR_LESS => InstructionCode.LessEqual,
            TokenType.COLLECTIVE_OR_LESS_EQUAL => InstructionCode.LessEqual,
            TokenType.COLLECTIVE_OR_GREATER => InstructionCode.GreaterThan,
            TokenType.COLLECTIVE_OR_GREATER_EQUAL => InstructionCode.GreaterEqual,
        };

        private static bool IsCollectiveOperator(TokenType type) =>
            type == TokenType.COLLECTIVE_EQUAL ||
            type == TokenType.COLLECTIVE_GREATER ||
            type == TokenType.COLLECTIVE_GREATER_EQUAL ||
            type == TokenType.COLLECTIVE_LESS ||
            type == TokenType.COLLECTIVE_LESS_EQUAL ||
            type == TokenType.COLLECTIVE_NOT_EQUAL ||
            type == TokenType.COLLECTIVE_OR_EQUAL ||
            type == TokenType.COLLECTIVE_OR_GREATER ||
            type == TokenType.COLLECTIVE_OR_GREATER_EQUAL ||
            type == TokenType.COLLECTIVE_OR_LESS ||
            type == TokenType.COLLECTIVE_OR_LESS_EQUAL ||
            type == TokenType.COLLECTIVE_OR_NOT_EQUAL;

        private Value ParseRange()
        {
            Value left = ParseAdditionSubtraction(); // Parse the start of the range

            if (_lexer.PeekNextToken().Type == TokenType.DOT_DOT)
            {
                _lexer.ConsumeToken(); // Consume '..'
                Value right = ParseAdditionSubtraction();
                TempValue resultList = new TempValue(_currentParseState.NextTempNumber++);

                // A user can do 10..0, the inverse of 0..10, should be accounted for in the Interpreter/VM.
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.NewRangeList, resultList, left, right));

                return resultList;
            }

            return left; // Not a range, just a regular expression.
        }

        private Value ParseAdditionSubtraction()
        {
            // This calls the next higher precedence level.
            Value left = ParseMulDivModulo();

            while (_lexer.PeekNextToken().Type == TokenType.PLUS || _lexer.PeekNextToken().Type == TokenType.MINUS)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseMulDivModulo();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);
                var opcode = (op.Type == TokenType.PLUS)
                    ? InstructionCode.Add
                    : InstructionCode.Subtract;

                _currentParseState.AddCodeInstruction(new InstructionLine(opcode, temp, left, right, op));

                left = temp; // The result becomes the new left-hand side for the next loop.
            }

            return left;
        }

        private static bool TokenTypeIsMulDivOrModulo(TokenType type)
            => type == TokenType.PERCENT ||
               type == TokenType.STAR ||
               type == TokenType.SLASH;

        //  MULTIPLICATION, DIVISION, MODULO (*, /, %)
        private Value ParseMulDivModulo()
        {
            Value left = ParseExponentation();

            while (TokenTypeIsMulDivOrModulo(_lexer.PeekNextToken().Type))
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseExponentation();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(GetInstructionCode(op.Type), temp, left, right, op));

                left = temp;
            }

            return left;
        }

        private Value ParseExponentation()
        {
            Value left = ParseUnary();

            while (_lexer.PeekNextToken().Type == TokenType.EXPONENT)
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParseUnary();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(GetInstructionCode(op.Type), temp, left, right, op));

                left = temp;
            }

            return left;
        }

        private Value ParseUnary()
        {
            Value left = ParsePostFix();

            while (IsUnaryOperator(_lexer.PeekNextToken().Type))
            {
                Token op = _lexer.ConsumeToken();
                Value right = ParsePostFix();

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(GetInstructionCode(op.Type), temp, left, right, op));

                left = temp;
            }

            return left;
        }

        private static bool IsPostFixToken(TokenType type) =>
            type == TokenType.INCREMENT ||
            type == TokenType.DECREMENT ||
            type == TokenType.BOOLEAN_FLIP;

        private Value ParsePostFix()
        {
            // ++ and --
            Value left = ParseAccess();
            bool operationPerformed = false;

            while (IsPostFixToken(_lexer.PeekNextToken().Type))
            {
                operationPerformed = true;
                Token op = _lexer.ConsumeToken();

                if (op.Type == TokenType.BOOLEAN_FLIP)
                {
                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Negate, left));
                    continue;
                }

                Value one = new NumberValue(1, NumberValue.NumberType.Integer);
                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                InstructionCode instrCode = (op.Type == TokenType.INCREMENT) ? InstructionCode.Add : InstructionCode.Subtract;

                _currentParseState.AddCodeInstruction(new InstructionLine(instrCode, temp, left, one, op));
                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Assign, left, temp, null, op));

                left = temp;
            }

            return operationPerformed ? new StatementCompleteValue() : left;
        }

        private Value ParseAccess()
        {
            // Array access [], get and set.
            Value left = ParsePrimary();

            while (true)
            {
                TokenType type = _lexer.PeekNextToken().Type;

                // Access get/set.
                if (type == TokenType.L_BRACKET)
                {
                    _lexer.ConsumeToken(); // Consume [.

                    Value index = ParseExpression();

                    ConsumeAndTryThrowIfUnequal(TokenType.R_BRACKET, "Bad list access, not ending bracket.");

                    // list[...] = ...
                    if (_lexer.PeekNextToken().Type == TokenType.EQUAL)
                    {
                        TempValue temp = new TempValue(_currentParseState.NextTempNumber++);
                        _lexer.ConsumeToken(); // Consume =.

                        Value valueToSet = ParseExpression();
                        _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.SetElement, left, index, valueToSet));
                        return valueToSet;
                    }
                    else // x = list[...]
                    {
                        TempValue valueToGet = new TempValue(_currentParseState.NextTempNumber++);
                        _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.GetElement, valueToGet, left, index));
                        left = valueToGet;
                    }
                }
                // Property access.
                else if (type == TokenType.DOT)
                {

                } // Function call.
                else if (type == TokenType.L_PAREN)
                {
                    _lexer.ConsumeToken(); // Consume (.
                    List<Value> arguments = new List<Value>();

                    if (_lexer.PeekNextToken().Type != TokenType.R_PAREN)
                    {
                        do
                        {
                            arguments.Add(ParseExpression());
                        }
                        while (ConsumeTokenIfMatch(TokenType.COMMA));
                    }

                    ConsumeAndTryThrowIfUnequal(TokenType.R_PAREN, "Missing closing ) after function call.");

                    foreach (var arg in arguments)
                    {
                        _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.PushParam, arg));
                    }

                    TempValue result = new TempValue(_currentParseState.NextTempNumber++);
                    _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.CallFunction, result, left, new NumberValue(arguments.Count)));

                    left = result;
                }
                else
                {
                    break;
                }
            }

            return left;
        }

        /// <summary>
        /// Checks if the next token's type matches the expected type.
        /// If it matches, the token is consumed and the method returns true.
        /// If it does not match, the token is NOT consumed and the method returns false.
        /// </summary>
        private bool ConsumeTokenIfMatch(TokenType expectedType)
        {
            if (_lexer.PeekNextToken().Type == expectedType)
            {
                _lexer.ConsumeToken(); // It's a match, so we consume it.
                return true;
            }

            return false; // Not a match, do nothing.
        }

        private Value ParsePrimary()
        {
            Token token = _lexer.ConsumeToken();
            if (token.Type == TokenType.NIL)
            {
                return new NilValue();
            }

            if (token.Type == TokenType.MINUS || token.Type == TokenType.BANG || token.Type == TokenType.TILDE)
            {
                Value operand = ParsePrimary();

                if (operand is NumberValue numVal)
                {
                    if (token.Type == TokenType.MINUS)
                    {
                        switch (numVal.Type)
                        {
                            case NumberValue.NumberType.Integer:
                                return new NumberValue(-Convert.ToInt32(numVal.Value), numVal.Type);
                            case NumberValue.NumberType.Float:
                                return new NumberValue(-float.Parse(numVal.Value.ToString()), numVal.Type);
                            case NumberValue.NumberType.Double:
                                return new NumberValue(-Convert.ToDouble(numVal.Value), numVal.Type);
                        }
                    }
                    else
                    {
                        return new BooleanValue((int)numVal.Value == 0);
                    }
                }

                Value temp = new TempValue(_currentParseState.NextTempNumber++);

                _currentParseState.AddCodeInstruction(new InstructionLine(InstructionCode.Negate, temp, operand));
                return temp;
            }

            switch (token.Type)
            {
                case TokenType.IDENTIFIER:
                    return new VariableValue(token.Text);
                case TokenType.NUMBER:
                    return NumberValue.FromToken(token);
                case TokenType.STRING:
                    return new StringValue(token.Text);
                case TokenType.TRUE:
                    return new BooleanValue(true);
                case TokenType.FALSE:
                    return new BooleanValue(false);
                case TokenType.F_STRING:
                    return ParseFString(token.Literal);
                case TokenType.CHARACTER:
                    return new CharValue((char)token.Literal);
                case TokenType.L_BRACKET:
                    // We are in list, either initialization, or [i] access.
                    return ParseList();
                case TokenType.MATCH:
                    return ParseMatch();
            }

            if (token.Type == TokenType.L_PAREN)
            {
                Value expr = ParseTernary();
                // Unclosed parentheses.
                _lexer.ConsumeToken();
                return expr;
            }

            // Log the token type for now, for debugging.
            Console.WriteLine(token);
            throw new Exception();
        }

        private void ConstructAndThrowParserException(int lineNum, int column, string errorMessage, string faultyLine, string expected, Token token)
        {
            ParserExceptionContext context = new ParserExceptionContext()
            {
                Column = column,
                FaultyLine = faultyLine,
                LineNum = lineNum,
                UnexpectedToken = token,
                ExpectedDescription = expected
            };
            throw new FluenceParserException(errorMessage, context);
        }

        private Token ConsumeAndTryThrowIfUnequal(TokenType expectedType, string errorMessage)
        {
            Token token = _lexer.ConsumeToken();
            if (token.Type != expectedType)
            {
                // for now just log.
                Console.WriteLine(errorMessage);
                // throw
            }
            return token;
        }
    }
}