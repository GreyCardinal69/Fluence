using static Fluence.FluenceByteCode;
using static Fluence.FluenceByteCode.InstructionLine;
using static Fluence.FluenceParser;

namespace Fluence
{
    /// <summary>
    /// A class meant for the optimization of bytecode generated by the parser before passing it to the virtual machine.
    /// </summary>
    internal static class FluenceOptimizer
    {
        internal static void OptimizeByteCode(ref List<InstructionLine> bytecode, ParseState parseState)
        {
            FuseGotoConditionals(ref bytecode);
            FuseCompoundAssignments(ref bytecode);
            RealignOffsets(ref bytecode, parseState);
        }

        internal static void OptimizeGotoInstructions(ref List<InstructionLine> bytecode, ParseState state)
        {
            FuseGotoConditionals(ref bytecode);
            RealignOffsets(ref bytecode, state);
        }

        private static void FuseCompoundAssignments(ref List<InstructionLine> bytecode)
        {
            for (int i = 0; i < bytecode.Count - 1; i++)
            {
                InstructionLine line1 = bytecode[i];
                if (line1 == null) continue;

                InstructionLine line2 = bytecode[i + 1];

                InstructionCode opCode = GetFusedOpcode(line1.Instruction);

                // Pattern Match:
                // line1: [Arithmetic] TempN TempN-1 Value
                // line2: [Assign]     Var   TempN
                // =>
                // line: [Arithmetic][Assign] Var TempN-1 Value
                if (
                    opCode != InstructionCode.Skip && line2.Instruction == InstructionCode.Assign &&
                    line1.Lhs is TempValue line1Lhs && line1.Rhs is TempValue line1Rhs &&
                    line2.Lhs is VariableValue line2Lhs && line2.Rhs is TempValue line2Rhs &&
                    line1Lhs.TempName == line2Rhs.TempName
                )
                {
                    InstructionLine fusedInsn = new InstructionLine(opCode, line2Lhs, line1Rhs, line1.Rhs2);
                    bytecode[i] = fusedInsn;
                    bytecode[i + 1] = null!;
                }
            }
        }

        private static void FuseGotoConditionals(ref List<InstructionLine> bytecode)
        {
            for (int i = 0; i < bytecode.Count - 1; i++)
            {
                InstructionLine line1 = bytecode[i];
                InstructionLine line2 = bytecode[i + 1];

                if (line1 == null) continue;
                if (line2 == null) continue;

                // Pattern Match:
                // Not/Equal             TempN    A          B
                // GotoIfTrue/False      JMP      TEMPN      .
                // =>
                // BranchIfEqual/Not     JMP      A          B   

                InstructionCode op = GetFusedGotoOpCode(line1.Instruction, line2.Instruction);

                if (op != InstructionCode.Skip)
                {
                    InstructionLine fusedInsn = new InstructionLine(op, line2.Lhs, line1.Rhs, line1.Rhs2);
                    bytecode[i] = fusedInsn;
                    bytecode[i + 1] = null!;

                }
            }
        }

        private static InstructionCode GetFusedGotoOpCode(InstructionCode op1, InstructionCode op2) => (op1, op2) switch
        {
            (InstructionCode.Equal, InstructionCode.GotoIfTrue) or (InstructionCode.NotEqual, InstructionCode.GotoIfFalse) => InstructionCode.BranchIfEqual,
            (InstructionCode.Equal, InstructionCode.GotoIfFalse) or (InstructionCode.NotEqual, InstructionCode.GotoIfTrue) => InstructionCode.BranchIfNotEqual,
            _ => InstructionCode.Skip,
        };

        private static InstructionCode GetFusedOpcode(InstructionCode op) => op switch
        {
            InstructionCode.Add => InstructionCode.AddAssign,
            InstructionCode.Subtract => InstructionCode.SubAssign,
            InstructionCode.Multiply => InstructionCode.MulAssign,
            InstructionCode.Divide => InstructionCode.DivAssign,
            InstructionCode.Modulo => InstructionCode.ModAssign,
            _ => InstructionCode.Skip
        };

        private static bool IsJumpInstruction(InstructionCode op) =>
            op == InstructionCode.Goto
            || op == InstructionCode.GotoIfTrue
            || op == InstructionCode.GotoIfFalse
            || op == InstructionCode.BranchIfEqual
            || op == InstructionCode.BranchIfNotEqual;

        private static void RealignOffsets(ref List<InstructionLine> bytecode, ParseState parseState)
        {
            int oldCount = bytecode.Count;

            var oldToNew = new int[oldCount];
            int newIdx = 0;
            for (int i = 0; i < oldCount; i++)
            {
                if (bytecode[i] != null)
                {
                    oldToNew[i] = newIdx++;
                }
                else
                {
                    oldToNew[i] = -1;
                }
            }
            int newCount = newIdx;

            int MapAddr(int oldAddr)
            {
                if (oldAddr == oldCount)
                {
                    return newCount;
                }

                if (oldAddr < 0)
                {
                    return oldAddr;
                }
                if (oldAddr >= oldCount)
                {
                    // For addresses beyond the end, also map to the new end.
                    return newCount;
                }

                if (oldToNew[oldAddr] == -1)
                {
                    int searchIndex = oldAddr + 1;
                    while (searchIndex < oldCount && oldToNew[searchIndex] == -1)
                    {
                        searchIndex++;
                    }

                    if (searchIndex >= oldCount)
                    {
                        return newCount;
                    }
                    return oldToNew[searchIndex];
                }

                return oldToNew[oldAddr];
            }

            void PatchFunctionValue(FunctionValue f)
            {
                f?.SetStartAddress(MapAddr(f.StartAddress));
            }

            for (int i = 0; i < oldCount; i++)
            {
                var insn = bytecode[i];
                if (insn is null) continue;

                if (IsJumpInstruction(insn.Instruction) && insn.Lhs is NumberValue targetAddr)
                {
                    insn.Lhs = new NumberValue(MapAddr((int)targetAddr.Value));
                }

                if (insn.Rhs is FunctionValue fvRhs) PatchFunctionValue(fvRhs);
                if (insn.Rhs2 is FunctionValue fvRhs2) PatchFunctionValue(fvRhs2);
            }

            foreach (var symbol in parseState.GlobalScope.Symbols.Values)
            {
                if (symbol is FunctionSymbol f) f.SetStartAddress(MapAddr(f.StartAddress));
                else if (symbol is StructSymbol s)
                {
                    PatchFunctionValue(s.Constructor);
                    foreach (var m in s.Functions.Values) PatchFunctionValue(m);
                }
            }

            foreach (var scope in parseState.NameSpaces.Values)
            {
                foreach (var symbol in scope.Symbols.Values)
                {
                    if (symbol is FunctionSymbol f) f.SetStartAddress(MapAddr(f.StartAddress));
                    else if (symbol is StructSymbol s)
                    {
                        PatchFunctionValue(s.Constructor);
                        foreach (var m in s.Functions.Values) PatchFunctionValue(m);
                    }
                }
            }

            bytecode.RemoveAll(item => item == null);
        }
    }
}