using static Fluence.FluenceByteCode;
using static Fluence.FluenceByteCode.InstructionLine;
using static Fluence.FluenceParser;

namespace Fluence
{
    /// <summary>
    /// A class meant for the optimization of bytecode generated by the parser before passing it to the virtual machine.
    /// </summary>
    internal static class FluenceOptimizer
    {
        internal static void OptimizeByteCode(ref List<InstructionLine> bytecode, ParseState parseState)
        {
            var removedIndices = new List<int>();

            FuseCompoundAssignments(ref bytecode, removedIndices);
            FuseGotoConditionals(ref bytecode, removedIndices);

            RealignOffsets(ref bytecode, parseState, removedIndices);
        }

        private static void FuseCompoundAssignments(ref List<InstructionLine> bytecode, List<int> removedIndices)
        {
            for (int i = 0; i < bytecode.Count - 1; i++)
            {
                InstructionLine line1 = bytecode[i];
                if (line1 == null) continue;

                InstructionLine line2 = bytecode[i + 1];

                InstructionCode opCode = GetFusedOpcode(line1.Instruction);

                // Pattern Match:
                // line1: [Arithmetic] TempN TempN-1 Value
                // line2: [Assign]     Var   TempN
                // =>
                // line: [Arithmetic][Assign] Var TempN-1 Value
                if (
                    opCode != InstructionCode.Skip && line2.Instruction == InstructionCode.Assign &&
                    line1.Lhs is TempValue line1Lhs && line1.Rhs is TempValue line1Rhs &&
                    line2.Lhs is VariableValue line2Lhs && line2.Rhs is TempValue line2Rhs &&
                    line1Lhs.TempName == line2Rhs.TempName
                )
                {
                    InstructionLine fusedInsn = new InstructionLine(opCode, line2Lhs, line1Rhs, line1.Rhs2);
                    bytecode[i] = fusedInsn;
                    bytecode[i + 1] = null!;
                    removedIndices.Add(i + 1);
                }
            }

        }

        private static void FuseGotoConditionals(ref List<InstructionLine> bytecode, List<int> removedIndices)
        {
            for (int i = 0; i < bytecode.Count - 1; i++)
            {
                InstructionLine line1 = bytecode[i];
                InstructionLine line2 = bytecode[i + 1];

                if (line1 == null) continue;
                if (line2 == null) continue;

                // Pattern Match:
                // Not/Equal             TempN    A          B
                // GotoIfTrue/False      JMP      TEMPN      .
                // =>
                // BranchIfEqual/Not     JMP      A          B   

                InstructionCode op = GetFusedGotoOpCode(line1.Instruction, line2.Instruction);

                if (op != InstructionCode.Skip)
                {
                    InstructionLine fusedInsn = new InstructionLine(op, line2.Lhs, line1.Rhs, line1.Rhs2);
                    bytecode[i] = fusedInsn;
                    bytecode[i + 1] = null!;
                    removedIndices.Add(i + 1);
                }
            }
        }

        private static InstructionCode GetFusedGotoOpCode(InstructionCode op1, InstructionCode op2) => (op1, op2) switch
        {
            (InstructionCode.Equal, InstructionCode.GotoIfTrue) or (InstructionCode.NotEqual, InstructionCode.GotoIfFalse) => InstructionCode.BranchIfEqual,
            (InstructionCode.Equal, InstructionCode.GotoIfFalse) or (InstructionCode.NotEqual, InstructionCode.GotoIfTrue) => InstructionCode.BranchIfNotEqual,
            _ => InstructionCode.Skip,
        };

        private static InstructionCode GetFusedOpcode(InstructionCode op) => op switch
        {
            InstructionCode.Add => InstructionCode.AddAssign,
            InstructionCode.Subtract => InstructionCode.SubAssign,
            InstructionCode.Multiply => InstructionCode.MulAssign,
            InstructionCode.Divide => InstructionCode.DivAssign,
            InstructionCode.Modulo => InstructionCode.ModAssign,
            _ => InstructionCode.Skip
        };

        private static bool IsJumpInstruction(InstructionCode op) =>
            op == InstructionCode.Goto
            || op == InstructionCode.GotoIfTrue
            || op == InstructionCode.GotoIfFalse
            || op == InstructionCode.BranchIfEqual
            || op == InstructionCode.BranchIfNotEqual;

        private static void RealignOffsets(ref List<InstructionLine> bytecode, ParseState parseState, List<int> _)
        {
            int oldCount = bytecode.Count;

            var oldToNew = new int[oldCount];
            Array.Fill(oldToNew, -1);

            int newIdx = 0;
            for (int i = 0; i < oldCount; i++)
            {
                if (bytecode[i] != null)
                {
                    oldToNew[i] = newIdx++;
                }
            }

            // Map an old address to the next valid new address (fall through if target removed).
            int MapAddr(int oldAddr)
            {
                if (oldAddr < 0) return 0;
                int i = Math.Min(oldAddr, oldCount - 1);
                while (i < oldCount && oldToNew[i] == -1) i++;
                if (i >= oldCount)
                {
                    // If the target was at/after the last removed block, clamp to the last live instruction.
                    // (Assumes there is at least one non-null instruction.)
                    int j = oldCount - 1;
                    while (j >= 0 && oldToNew[j] == -1) j--;
                    return j >= 0 ? oldToNew[j] : 0;
                }
                return oldToNew[i];
            }

            // Patch jump targets.
            for (int i = 0; i < oldCount; i++)
            {
                var insn = bytecode[i];
                if (insn is null) continue;

                if (IsJumpInstruction(insn.Instruction) && insn.Lhs is NumberValue targetAddr)
                {
                    int oldTarget = (int)targetAddr.Value;
                    int newTarget = MapAddr(oldTarget);
                    insn.Lhs = new NumberValue(newTarget);
                }
            }

            // Patch function/struct entry points using the same MapAddr.
            void PatchFunctionValue(FunctionValue f)
            {
                f.SetStartAddress(MapAddr(f.StartAddress));
            }

            foreach (var symbol in parseState.GlobalScope.Symbols.Values)
            {
                if (symbol is FunctionSymbol f)
                {
                    f.SetStartAddress(MapAddr(f.StartAddress));
                }
                else if (symbol is StructSymbol s)
                {
                    if (s.Constructor != null) PatchFunctionValue(s.Constructor);
                    foreach (var m in s.Functions.Values) PatchFunctionValue(m);
                }
            }

            foreach (var scope in parseState.NameSpaces.Values)
            {
                foreach (var symbol in scope.Symbols.Values)
                {
                    if (symbol is FunctionSymbol f)
                    {
                        f.SetStartAddress(MapAddr(f.StartAddress));
                    }
                    else if (symbol is StructSymbol s)
                    {
                        if (s.Constructor != null) PatchFunctionValue(s.Constructor);
                        foreach (var m in s.Functions.Values) PatchFunctionValue(m);
                    }
                }
            }

            bytecode.RemoveAll(item => item == null);
        }
    }
}