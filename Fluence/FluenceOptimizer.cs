using System;
using static Fluence.FluenceByteCode;
using static Fluence.FluenceByteCode.InstructionLine;
using static Fluence.FluenceParser;
using static Fluence.FluenceParser.ParseState;

namespace Fluence
{
    /// <summary>
    /// A class meant for the optimization of bytecode generated by the parser before passing it to the virtual machine.
    /// </summary>
    internal static class FluenceOptimizer
    {
        internal static void OptimizeByteCode( ref List<InstructionLine> bytecode, ParseState parseState)
        {
            var removedIndices = new List<int>();

            FuseCompoundAssignments(ref bytecode, removedIndices);
            RealignOffsets(ref bytecode, parseState, removedIndices);


        }

        private static void FuseCompoundAssignments(ref List<InstructionLine> bytecode, List<int> removedIndices)
        {
            for (int i = 0; i < bytecode.Count - 1; i++)
            {
                InstructionLine line1 = bytecode[i];
                if (line1 == null) continue;

                InstructionLine line2 = bytecode[i + 1];
 
                InstructionCode opCode = GetFusedOpcode(line1.Instruction);

                // Pattern Match:
                // line1: [Arithmetic] TempN TempN-1 Value
                // line2: [Assign]     Var   TempN
                // =>
                // line: [Arithmetic][Assign] Var TempN-1 Value
                if (
                    opCode != InstructionCode.Skip && line2.Instruction == InstructionCode.Assign &&
                    line1.Lhs is TempValue line1Lhs && line1.Rhs is TempValue line1Rhs &&
                    line2.Lhs is VariableValue line2Lhs && line2.Rhs is TempValue line2Rhs &&
                    line1Lhs.TempName == line2Rhs.TempName
                )
                {
                    InstructionLine fusedInsn = new InstructionLine(opCode, line2Lhs, line1Rhs, line1.Rhs2);
                    bytecode[i] = fusedInsn;
                    bytecode[i + 1] = null!;
                    removedIndices.Add(i + 1);
                }
            }

            bytecode.RemoveAll(item => item == null);
        }

        private static InstructionCode GetFusedOpcode(InstructionCode op) => op switch
        {
            InstructionCode.Add => InstructionCode.AddAssign,
            InstructionCode.Subtract => InstructionCode.SubAssign,
            InstructionCode.Multiply => InstructionCode.MulAssign,
            InstructionCode.Divide => InstructionCode.DivAssign,
            InstructionCode.Modulo => InstructionCode.ModAssign,
            _ => InstructionCode.Skip
        };

        private static void RealignOffsets(ref List<InstructionLine> bytecode, ParseState parseState, List<int> removedIndices)
        {
            if (removedIndices.Count == 0) return;

            removedIndices.Sort();

            int GetNewAddress(int oldAddress)
            {
                int shift = 0;
                foreach (int removedIdx in removedIndices)
                {
                    if (removedIdx < oldAddress)
                    {
                        shift++;
                    }
                    else
                    {
                        break;
                    }
                }
                return oldAddress - shift;
            }

            for (int i = 0; i < bytecode.Count; i++)
            {
                var instruction = bytecode[i];
                if (instruction.Instruction is InstructionCode.Goto or InstructionCode.GotoIfTrue or InstructionCode.GotoIfFalse)
                {
                    if (instruction.Lhs is NumberValue targetAddr)
                    {
                        int oldTarget = (int)targetAddr.Value;
                        int newTarget = GetNewAddress(oldTarget);
                        instruction.Lhs = new NumberValue(newTarget);
                    }
                }
            }

            // Update functions in the Global Scope.
            foreach (var symbol in parseState.GlobalScope.Symbols.Values)
            {
                if (symbol is FunctionSymbol func)
                {
                    func.SetStartAddress(GetNewAddress(func.StartAddress));
                }
                else if (symbol is StructSymbol structSym)
                {
                    // Also need to patch methods and constructors inside structs.
                    if (structSym.Constructor != null)
                    {
                        structSym.Constructor.SetStartAddress(GetNewAddress(structSym.Constructor.StartAddress));
                    }
                    foreach (var method in structSym.Functions.Values)
                    {
                        method.SetStartAddress(GetNewAddress(method.StartAddress));
                    }
                }
            }

            // Update functions in all Namespaces.
            foreach (var scope in parseState.NameSpaces.Values)
            {
                foreach (var symbol in scope.Symbols.Values)
                {
                    if (symbol is FunctionSymbol func)
                    {
                        func.SetStartAddress(GetNewAddress(func.StartAddress));
                    }
                    else if (symbol is StructSymbol structSym)
                    {
                        if (structSym.Constructor != null)
                        {
                            structSym.Constructor.SetStartAddress(GetNewAddress(structSym.Constructor.StartAddress));
                        }
                        foreach (var method in structSym.Functions.Values)
                        {
                            method.SetStartAddress(GetNewAddress(method.StartAddress));
                        }
                    }
                }
            }
        }
    }
}