namespace Fluence
{
    /// <summary>
    /// The abstract base type for all values that can exist in the Fluence runtime or be represented in bytecode.
    /// All value types are immutable records.
    /// </summary>
    internal abstract record class Value;

    /// <summary>Represents a single character literal.</summary>
    internal sealed record class CharValue(char Value) : Value
    {
        public override string ToString() => $"Char: '{Value}'";
    }

    /// <summary>Represents a string literal.</summary>
    internal sealed record class StringValue(string Value) : Value
    {
        public override string ToString() => $"String: \"{Value ?? "null"}\"";
    }

    /// <summary>Represents the two boolean states, true and false.</summary>
    internal sealed record class BooleanValue(bool Value) : Value
    {
        public override string ToString() => $"Boolean: {Value}";
    }

    /// <summary>Represents the nil value.</summary>
    internal sealed record class NilValue : Value
    {
        public override string ToString() => "NilValue";
    }


    /// <summary>Represents a numerical value, which can be an Integer, Float, or Double.</summary>
    internal sealed record class NumberValue : Value
    {
        internal enum NumberType
        {
            Integer,
            Float,
            Double
        }

        internal object Value { get; }
        internal NumberType Type { get; }

        internal NumberValue(object literal, NumberType type = NumberType.Integer)
        {
            Value = literal;
            Type = type;
        }

        public static NumberValue FromToken(Token token)
        {
            string lexeme = token.Text;

            // Check for float suffix
            if (lexeme.EndsWith('f'))
            {
                // It's a float. Parse it as such.
                string floatStr = lexeme[..^1];
                if (float.TryParse(floatStr, out float floatVal))
                {
                    return new NumberValue(floatVal, NumberType.Float);
                }
            }
            // Check for decimal point (but not float) -> double
            else if (lexeme.Contains('.', StringComparison.Ordinal))
            {
                if (double.TryParse(lexeme, out double doubleVal))
                {
                    return new NumberValue(doubleVal, NumberType.Double);
                }
            }
            // Otherwise, it's an integer.
            else
            {
                if (int.TryParse(lexeme, out int intVal))
                {
                    return new NumberValue(intVal, NumberType.Integer);
                }
            }

            if (double.TryParse(lexeme, out double fallbackVal))
            {
                return new NumberValue(fallbackVal, NumberType.Double);
            }

            // SHOULD BE A PARSER ERROR, this for now.
            throw new FormatException($"Invalid number format: '{lexeme}'");
        }

        public override string ToString()
        {
            return $"NumberValue ({Type}): {Value}";
        }
    }

    /// <summary>A special value indicating that a statement has completed but produced no value. Used for postfix ops.</summary>
    internal sealed record class StatementCompleteValue : Value
    {
        public override string ToString() => "StatementComplete";
    }

    /// <summary>A descriptor representing an element access operation.</summary>
    internal sealed record class ElementAccessValue : Value
    {
        internal Value Target { get; }
        internal Value Index { get; }

        internal ElementAccessValue(Value target, Value index)
        {
            Target = target;
            Index = index;
        }

        public override string ToString()
        {
            return $"ElementAccessValue";
        }
    }

    /// <summary>A descriptor for a broadcast call template.</summary>
    internal sealed record class BroadcastCallTemplate : Value
    {
        // The function to be called.
        internal Value Callable { get; }
        internal List<Value> Arguments { get; }
        // The underscore used in pipes.
        internal int PlaceholderIndex { get; }

        public BroadcastCallTemplate(Value callable, List<Value> args, int placeholderIndex)
        {
            Callable = callable;
            Arguments = args;
            PlaceholderIndex = placeholderIndex;
        }
    }

    /// <summary>A descriptor representing a temporary variable generated by the parser.</summary>
    internal sealed record class TempValue : Value
    {
        internal string TempName;

        internal TempValue(int num)
        {
            TempName = $"__Temp{num}";
        }

        internal TempValue(int num, string name)
        {
            TempName = $"{name}{num}";
        }

        public override string ToString()
        {
            return $"TempValue: {TempName}";
        }
    }

    /// <summary>Represents a function or method. Can be a user-defined function with a bytecode address or a native intrinsic.</summary>
    internal sealed record class FunctionValue : Value
    {
        // The name of the function (for debugging/stack traces).
        internal string Name { get; }
        // The number of parameters the function expects.
        internal int Arity { get; }
        // The address of the first instruction of the function's body in the bytecode.
        internal int StartAddress { get; private set; }

        internal readonly IntrinsicMethod IntrinsicBody;
        internal readonly bool IsIntrinsic;

        internal FunctionValue(string name, int arity, int startAddress)
        {
            Name = name;
            Arity = arity;
            StartAddress = startAddress;
        }

        public FunctionValue(string name, int arity, IntrinsicMethod body)
        {
            Name = name;
            Arity = arity;
            StartAddress = -1;
            IsIntrinsic = true;
            IntrinsicBody = body;
        }

        internal void SetStartAddress(int adr)
        {
            StartAddress = adr;
        }

        public override string ToString()
        {
            return $"FunctionValue: {Name} {FluenceDebug.FormatByteCodeAddress(StartAddress)}, {Arity} args.";
        }
    }

    /// <summary>A descriptor representing a property access operation.</summary>
    internal sealed record class PropertyAccessValue : Value
    {
        internal Value Target;
        internal string FieldName;

        internal PropertyAccessValue(Value target, string fieldName)
        {
            Target = target;
            FieldName = fieldName;
        }

        public override string ToString()
        {
            return $"FieldAccess<{Target}:{FieldName}>";
        }
    }

    /// <summary>Represents a variable by its name. The VM resolves this to a value in a scope.</summary>
    internal sealed record class VariableValue : Value
    {
        internal string IdentifierValue;

        internal VariableValue(string identifierValue)
        {
            IdentifierValue = identifierValue;
        }

        public override string ToString()
        {
            return $"VariableValue: {IdentifierValue}";
        }
    }
 
     /// <summary>Represents a specific member of an enum.</summary>
    internal sealed record class EnumValue : Value
    {
        internal string EnumTypeName { get; }
        internal string MemberName;
        internal int Value;

        internal EnumValue(string enumTypeName, string memberName, int value)
        {
            EnumTypeName = enumTypeName;
            MemberName = memberName;
            Value = value;
        }

        public override string ToString()
        {
            return $"EnumValue: {EnumTypeName}.{MemberName}";
        }
    }
}